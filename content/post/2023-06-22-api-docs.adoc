---
layout:     post
title:      "API документация с DocOps и ChatGPT"
subtitle:   "Как автоматизировать написание API-документации"
description: "Описание моего опыта написания автоматизации документации на API Bot.one"
date: 2023-06-15
author:     "Dasha"
image: "/images/AdobeStock_466985843.jpeg"
showonlyimage: true
tags:
    - DocAsCode
URL: "/2023/06/22/api/"
categories: [ DocAsCode ]
---
:imagesdir: \images\

= API документация с DocOps и ChatGPT

Описание методов API до сего дня висела у нас на том же домене в оболочке Swagger. Меня как технического писателя это вполне устраивало. Спецификация генерилась сама из кода. Методов было немного, в любой момент я могла поставить разработчику задачу изменить такое-то предложение в сваггере на другое. Он шел и правил комментарии в коде. Пользователь мог посмотреть методы, а если у него есть логин Bot.one, то даже попробовать их на реальном сервере под своим аккаунтом.

image::2023-06-22_142610.png[Описание API Bot.one в Swagger]

.Минусы у такого состояния были следующие:
* Периодически кто-нибудь просил не html, а красивый печатный документик, который можно отправить клиенту.
* Сваггер -- это, конечно, хорошо и подробно, но не хватало каких-то общих статей: что может наш API, как им воспользоваться и пр.

И вот я начала писать документик по API. Но мы же за DocOps, поэтому нужно автоматизировать все, что можно автоматизировать.

.Для начала напомню свой стек:
* Пишем исходники в .adoc.
* Собираем html-справку их этих исходников в HUGO.
* Собираем pdf-мануал из этих исходников в Asciidoctor PDF.

.Таким образом намечался следующий план действий:
. Настроить генерацию описания эндпоинтов из кода/сваггера в .adoc.
. Написать общие статьи по использованию API Bot.one.
. Настроить структуру раздела  API в html-справке.
. Собрать pdf-документ по API.

=== Генерация описания эндпоинтов

Итак, первый этап автоматизации -- генерация файла .adoc из спецификации .json (которая генерируется из комментариев в коде).

Для генерации использую link:https://github.com/openapi-contrib/openapi3-generator[OpenAPI 3 Generator]. На вход генератор принимает .yaml, на выход - в оригинале markdown. link:https://github.com/fiddlededee[Николай Поташников] добавил в него шаблон asciidoctor.

После пробной попытки понимаю, что OG очень здорово генерирует документ, но шаблон меня не совсем устраивает.

.Нужно изменить следующее:
* Убрать локализацию, так как используем только ru.
* Уменьшить количество заголовков и изменить их иерархию.
* Изменить таблицы с параметрами: добавить примеры, обязательность и пр.
* Добавить пример запроса.
* Добавить описание кодов ошибок.

.Лезем в шаблон и правим его:
. Убираем все атрибуты ":i18n-h-".
. Убираем лишние патриалы.

В результате у меня получился очень простой шаблон:

[source, asciidoc]
----
//tag::body[]
{{> paths }}
//end::body[]
----

Дальше идем в *.partials* и правим там *paths.adoc.hbs* и все вложенные патриалы.

Чтобы структура документа была такой, которая меня устраивала, не хватало операций с данными. Для этого в OpenAPI Generator используются *.helpers*. Единственный хелпер, который помогал устанавливать условия для попадания данных в шаблон -- *equal.js*. Он проверял, одинаковые аргументы или нет.

.Мне требовалось больше условий. Например:
* Если код ответа меньше, чем 300 -- написать его в разделе "Успешный ответ".
* Если код ответа больше или равен 300 -- написать его в разделе "Коды ошибок".

На JS я писать не умею. А если чего-то не умеешь, то ask GPT.

image::2023-06-22_175336.png[GPT помог создать хелпер]

В итоге он написал для меня следующие хелперы:

.Если a больше или равно b
[source, JS]
----
module.exports = (Handlebars, _) =>{

  Handlebars.registerHelper('if_bt', function(a, b, opts) {
    if (a >= b) {
        return opts.fn(this);
    } else {
        return opts.inverse(this);
    }
  });

}
----

.Если a меньше b
[source, JS]
----
module.exports = (Handlebars, _) =>{

  Handlebars.registerHelper('if_lt', function(a, b, opts) {
    if (a < b) {
        return opts.fn(this);
    } else {
        return opts.inverse(this);
    }
  });

}
----

Я добавила эти условия в шаблон и теперь документация по API генерировалась так, как мне нужно.

Полученный файл можно использовать as is. Но мне для справки нужны отдельные статьи, поэтому совместно в GPT пишем скрипт на разделение файла на несколько отдельных. Скрипт нужно доработать, но пока и так сойдет.

[source, py]
----
with open('openapi.adoc', 'r', encoding='utf-8') as f:
    content = f.read()

sections = []
current_section = ''
for line in content.split('\n'):
    if line.startswith('== '):
        sections.append(current_section)
        current_section = line + '\n'
    else:
        current_section += line + '\n'
sections.append(current_section)

for i, section in enumerate(sections[1:]):
    filename = f'section_{i}.adoc'
    with open(filename, 'w') as f:
        f.write(section)
----

NOTE: (для себя) нужно добавить переменную на место названия исходного файла, нужно добавить именование полученных файлов по тегу внутри них.

В итоге для каждого эндпоинта получилась отдельная статья на html-хелпе и раздел в pdf-мануале.

image::2023-06-23_123933.png[Пример статьи на html-хелпе]

image::2023-06-23_124330.png[Пример раздела в pdf-мануале]

****
.Получился следующий алгоритм работы с эндпоинтами:
. Забираем автоматически сгенерированный из кода json со спецификацией.
. Конвертируем его в yaml.
. Генерируем из него adoc `og openapi.yaml asciidoctor`.
. Запускаем скрипт и разделяем файл на несколько статей.
****

=== Написание общих статей

На втором этапе подготовки дока нужно было добавить общие статьи: что позволяет Bot.one API, как с ним работать и пр.

Опять помог GPT. Я задала ему вопрос о том, как пользователи могут использовать наш API.

image::2023-06-23_115753.png[Как использовать API по мнению ChatGPT]

Конечно, я неправильно задала вопрос и он мне наврал с три короба. Когда позже я задавала тот же вопрос, он уже честно мне говорил, что не может ходить по ссылкам. Но, тем не менее, ответ был дан. Я могу извлечь из его ответа то, что действительно нам подойдет.

Таким образом я отметила направления, как можно использовать API Bot.one и развила их в отдельные статьи, типа "Создавать диалоги", которые в свою очередь описывали общие возможности по созданию диалогов, отсылали к подробному описанию конкретных эндпоинтов и рассказывали об их отличиях.

.В эту же часть я добавила статьи:
* про авторизацию;
* различие версий (у нас одновременно доступны две версии API и пользователи не всегда понимают, какую им нужно смотреть);
* что-то вроде getting started: как отправлять запросы в swagger и в postman.

Кроме того, я создала коллекции в Postman с максимальным описанием эндпоинтов, примерами и пр. -- экспортировала эти коллекции и добавила их в статью на help. Теперь читатели могут увидеть баннер сбоку, скачать коллекции и пользовать их в Postman.

image::2023-06-23_130327.png[Коллекции API Bot.one в Postman]

=== Формирование всего раздела или документа

После вводных статей я добавила референсы самих эндпоинтов.

В итоге получилось следующее содержание раздела в html-справке.

image::2023-06-23_130225.png[Содержание раздела API в html-справке]

И следующее содержание pdf-документа.

image::2023-06-23_122258.png[Содержание PDF-документа по API]
